## 数据结构

## 基本概念

数据结构：是相互之间存在一种或者多种特定关系的数据元素的集合

逻辑结构：是指数据对象中数据元素之间的相互关系

逻辑结构分类：

​	1、集合结构：集合之中的元素除了同属于一个集合之外，没有任何关系

​	2、线性结构：线性结构的数据元素是一对一的关系

​	3、树形结构：树形结构中的数据元素存在一种一对多的层次关系

​	4、图形结构：图形结构的数据元素是多对多的关系

物理结构：是指数据的逻辑结构在计算机中的存储形式

​	1、顺序存储：是把数据存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系一致。

​	2、链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的

### 算法

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的序列，并且每条指令表示一个或者多个操作

算法与数据结构息息相关，难以分离。

### 线性表

零个或者多个数据元素的有限序列

![01](C:\Users\tz\Pictures\数据结构\01.png)



特点：除了第一个元素外，每个元素只有一个前驱，除了最后一个元素外，每个元素只有一个后继

线性表的长度为线性表的元素个数，当个数为0时，表示线性表为空。

#### 线性表的操作

```c
InitList(*L);  //初始化操作，建立一个空的线性表
listEmpty(L);  //若线性表为空，则返回true，否则返回false
ClearList(*L);  //将线性表清空
GetElem(L,i,*e);  //将线性表中第i个元素返回给e
LocateElem（L，e);  //在线性表中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号，否则，返回0表示失败
ListInsert(*L,i,e);  //在线性表中第i个位置插入元素e
ListDelete（*L，i，*e）；  //删除线性表L中第i个元素，并用e返回其值
ListLength（L）；  //返回线性表的元素个数
```

##### 线性表的顺序存储结构

指的是用一段连续的地址存储单元依次存储线性表的数据元素

顺序表的插入算法

​	1、如果插入的位置不合理，抛出异常

​	2、如果线性表的长度大于等于数组的长度，则抛出异常或者动态增加容量

​	3、从最后一个元素开始向前遍历到第i个位置，分别向后挪一位

​	4、将要插入的元素填入位置i

​	5、表长加一

```c++
/*初始条件：顺序表L已经存在，1<=i <= ListLength(L)
操作结果：在L中的第i个位置插入数据元素e，L的长度加1*/

Status ListInsert(Sqlist *L,int i,ElemenType e)
{
    int k;
    if(L->length==MAXSIZE)  //表示顺序表已经满了
        return ERROR;
    if(i<1 || i > L->length+1)
        return ERROR;
    if(i < L->length)
        for(k = L->length-1;k>=i-1;k--)
        {
            L->data[k+1] = L->data[k];
        }
    L->data[i-1] = e;  //插入元素
    L->length ++;
    return OK;
}
```

![顺序表](C:\Users\tz\Pictures\数据结构\顺序表.png)



##### 顺序表的删除

算法思路：

​	1、如果删除位置不合理，抛出异常

​	2、取出删除元素

​	3、从删除位置开始遍历到最后一个元素位置，分别向前移动一个位置

​	4、表长-1

代码如下：

```c++
/*初始条件：顺序表L已经存在，1<=i <= ListLength(L)
操作结果：在L中的第i个位置插入数据元素e，L的长度加1*/
Status ListDelete(Sqlist *L,int i,ElemenType e)
{
    int k;
    if(L->length == 0)  //线性表为空
        return ERROR;
    if(i<1 || i>L->length)//删除位置不正确
        return ERROR;
    *e = L->data[i-1];  //取出要删除的元素
    
    if(i < L->length)
    {
        for(k=i;k <L->length;k++)
        {
            L->data[k-1] =L->data[k];
        }
    }
    L->length--;  //表的长度减一
    return OK;
}
```

时间复杂度分析：

在存和读取数据的时候，时间复杂度都是O（1），插入或者删除时，最好情况是O（1），最坏的情况是O（n）；

**优点**：可以快速地存取表中任意位置元素

**缺点**：插入或者删除数据麻烦，难以确定存储空间，造成存储空间“碎片”

